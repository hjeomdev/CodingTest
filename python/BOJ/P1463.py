import sys

n = int(sys.stdin.readline().rstrip())

# while N != 1:
#     if N % 3 == 0:
#         N //= 3
#     elif N % 2 == 0:
#         N //= 2
#     else:
#         N -= 1
# 이렇게 푸는 것은 브루트포스다.

dp = [0] * (n + 1)

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + 1
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)
# 브루트포스 방법은 n에서 1까지 계산하는 방법이라면
# dp 방법은 1에서 n까지 계산하는 방법이다

# n <- 1 to 10 해서 왜 dp를 사용하면 효율적인지 보겠다.
# 1:  (0번)
# 2: 1 (1번)
# 3: 1 (1번)
# 4: 2 -> 1 (2번)
# 5: 4 -> 2 -> 1 (3번) 이쯤에서 dp를 쓸 이유가 느껴진다.
# 6: 2 -> 1 (2번)
# 7: 6 -> 2 -> 1 (3번) 여기에서도 dp를 쓸 이유가 느껴진다.
# 8: 4 -> 2 -> 1 (3번)
# 9: 3 -> 1 (2번)
# 10: 9 -> 3 -> 1 (3번)
# 횟수의 최솟값을 구하기 때문에 특정 n의 횟수는 1 ... n-1의 수에서 가져다 써도 되는 것이다.
# 미리 계산한 것을 갖다 쓰는 것이(메모이제이션) 바로 dp의 목적이다.

# 1에서 부터 누적해서 구하고 있다는 것은, i-1번째 수의 횟수에 1을 더한 값(-1을 하는 경우)이 i번째 수의 푓수가 될 수 있는 것이다.
# 다만, -1을 하는 것보다 3을 나누거나 2를 나누는 것이 최솟값이 될 가능성이 더 크므로 min()로 어느 것이 더 적합한지 따진다.


# print(dp)
sys.stdout.write(str(dp[n]))
